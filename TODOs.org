* GUI
** TODO ncurses ai for hnefatafl
   SCHEDULED: <2017-01-17 Tue>
** TODO fix hnefatafl colors
   SCHEDULED: <2017-01-17 Tue>
* Optimize
** target functions
*** getPiece
**** try other storage methods, should be easier now. Try vector.
**** Pie in the sky: custom 2d zipper.
***** adjust square datatype so that it carries the board around it, means minimal adjustment to functions using go.
*** findnextPiece
**** using way too much memory, something's amiss.
*** rewrite turn runner to non-monadic version (need not be pretty) to compare performance.
**** if performance gains significant, look into optimization of monadic version.
*** possible go efficiency gain
**** surround board with edge squares, don't test each move for legitimacy, just hit an edge square when reached.
***** either convert edge to nothing or deal with edge in functions.
* Engine
** TODO loss after repeated moves
** TODO implement history (potentially limited by the number of moves within which repetition is forbidden)
** TODO surround capture
** TODO game end when king occupies corner adacent sqaure. Saves time and cpu.
** TODO improve code organization, potentially make even smaller files.
** TODO separate board storage method such that one can easily swap out backends.
   direct access to neighboard may turn out to be more important than fast lookup as i implement
   remaining engine functions and more ai functions
** reorganize turn functions?
** route functions needed for console runner, etc, through engine?
** consider lenses for field access
** consider lenses for field access in state monad during turns
** reconsider the postturn format
*** it is good to have either wrap it to cut short evaluation, 
** maybe back to x,y
** maybe moves to a 4 tuple with only the last coord in each dir
* AI
** General
*** Board evaluation
**** Black
***** cornerGuard
****** DONE make cornerGuard AI function not depend on lastmove, just look at board
       CLOSED: [2017-01-11 Wed 19:25]
****** TODO enhance cornerGuard function to prefer complete corners.
***** TODO discourage protecting adjacent to corners
***** TODO prioritize corners just behind king stoppage, perhaps at roughly same level as taking
***** TODO when cutting off king moves prioritize moving next to a friendly piece
***** TODO no points for threatening pieces that are blocking king escape
***** TODO deincentivize relying on white pieces to block king. Somehow.
***** TODO awareness of which pieces are most important for blocking king, for example by finding route to corner which is shortest and has fewest pieces in it
**** White
**** General
***** TODO don't award points for threatening a piece i want to exist
****** can potentially be solved by looking ahead.
****** can also be solved by finding piece(s) that would take the piece, and seeing what would happen if they we moved.
***** TODO functions to assess changed risk to pieces affected by the last move
****** move to avoid or protect against capture necessary to make candidates for recursive move selection
****** DONE was the piece in danger where it was
       CLOSED: [2017-01-11 Wed 19:39]
       tweak this to make sure that when the king is blocked from the corner by a corner adjacent defender
       and then moves out by just one square, the corner adjacent defender moves out as well to block instead
       of bringing in a new piece, because otherwise the king will just move back and kill the original defender.
       in practical terms this will mean scoring moving a (corner adjacent) carefully against king stoppage.
       On second thought, this might be more easily solved by simply looking ahead one move, either usign MCTS or
       a more basic manual lookahead of the best moves.
****** DONE is the piece in danger where it is now
       CLOSED: [2017-01-11 Wed 19:39]
       already have a function for this, make sure it is in step so that there isn't a net positive for moving from
       risk to risk for example
****** does the absence of this piece in its previous position put its surrounding pieces at increased risk
       basically check if the closest piece in one direction can threaten any pieces if it were to move to any
       square on the other side or the vacated square.
******* only need to analyze perpendicularly
****** does moving to the new position prevent other things from being threatened
******* only need to analyze perpendicularly
****** does it threaten new pieces?
******* only need to analyze perpendicularly
***** TODO function to assess changed risk to pieces surrounding captured piece(s)
*** TODO write a basic implementation of MCTS
*** TODO better implementation of ai: combination of monte cristo tree search with board judgements I'm making
*** Improving AI for user experience
**** Difficulty levels
***** pass in difficulty to ai
***** hardest difficulty will only select from moves tied for best score. next hardest will select from moves with the two highest rankings, etc.
**** Different Strategies
***** mechanism for randomly choosing an ai strategy
***** sometimes choose a shortsighted move (an attempt at capture that could result the AI's piece being capture next turn) randomly a certain what percentage of the time. The frequency of short-sighted moves could be a facet on which difficulty is adjusted
***** have an aggressive ai that is willing to lose a piece to take a piece.
**** move selection
***** instead of taking the first move with highest score, get all moves which share the highest score and choose a random one. So the game isn't so repetitive.
* Article
** why hnefatafl presents and interesting ai challenge
** methods tried vs those used
** high branching factor, unable to look very far into the future at the beginning of the game.
** non-recursive board judgement: function to assess current state and predict future state. less than a dozen measurement function and the game was not playing like a total idiot, but was still easy to beat.
** min-max with pruning and shallow recursion
